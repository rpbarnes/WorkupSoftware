#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
New database browser implementing some things that should allow for a more smooth browsing experience.
"""

import pymongo
import nmrfit
import database as dtb
import sys
import platform
import matlablike as pys
from lmfit import Parameters,minimize

import numpy as np
from PyQt4 import QtCore, QtGui
from PyQt4.QtCore import *
from PyQt4.QtGui import *
from mainwindow import Ui_MainWindow

import matplotlib
from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure

#{{{ Fit functions 
def analyticLinear(params,x):
    slope = params['slope'].value
    intercept = params['intercept'].value
    return slope * x + intercept

def residualLinear(params, x, data, eps_data):
    return (data-analyticLinear(params,x))/eps_data # note the weighting is done here
params = Parameters()
params.add('slope', value=1)
params.add('intercept', value=2.5)
#}}}

class MyDatabaseBrowser(QtGui.QDialog):#{{{
    """
    This is generated by clicking the button and it pulls data base values for each possible key.
    """
    def __init__(self, guiParent,parent=None):
        super(MyDatabaseBrowser, self).__init__(parent)

        self.parent = guiParent
        self.buttonBox = QtGui.QDialogButtonBox(self)
        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
        self.buttonBox.accepted.connect(self.onAccept)
        self.buttonBox.rejected.connect(self.onReject)

        self.iniBox = QtGui.QVBoxLayout(self)
        self.setLayout(self.iniBox)
        scroll = QtGui.QScrollArea(self)
        self.iniBox.addWidget(scroll)
        scroll.setWidgetResizable(True)
        scrollContent = QtGui.QWidget(scroll)
        scrollContent.setGeometry(QtCore.QRect(60, 50, 241, 211))

        #self.scrollArea = QtGui.QScrollArea(self)
        self.vbox = QtGui.QVBoxLayout(scrollContent)
        scrollContent.setLayout(self.vbox)

        #self.spinbox = QtGui.QSpinBox(self)
        #self.spinbox.setRange(0,10)
        #self.spinbox.valueChanged.connect(self.onChangeValue)
        #self.vbox.addWidget(self.spinbox)
        self.grid = QtGui.QGridLayout()
        self.itemlist = []
        self.vbox.addLayout(self.grid)
        self.vbox.addStretch(1)

        self.vbox.addWidget(self.buttonBox)
        ### example for populating each combobox
        #keyVals = [str(k) for k in self.collection.distinct('setType')]
        #keyVals.insert(0,'Select')
        #self.main_frame.setTypeComboBox.addItems(keyVals)
        #self.main_frame.setTypeComboBox.setEditable(True)

        #for label, combobox in self.itemlist:
        #    label.deleteLater()
        #    combobox.deleteLater()
        #self.itemlist = []
        for count,key in enumerate(self.parent.databaseParamsDict.keys()):
            label = QtGui.QLabel('%s'%key)
            combobox = QtGui.QComboBox()
            keyVals = [str(k) for k in self.parent.collection.distinct(key)]
            keyVals.insert(0,'Select')
            combobox.addItems(keyVals)
            #combobox.setEditable(True)
            self.grid.addWidget(label, count, 0)
            self.grid.addWidget(combobox, count, 1)
            self.itemlist.append([key, label, combobox])
        
        scroll.setWidget(scrollContent)
    def onAccept(self):
        """
        Read from all combo boxes and return a search dictionary and close the dialog window
        """
        self.parent.searchDict = {}
        for key, label, combobox in self.itemlist:
            text = str(combobox.currentText())
            if text != 'Select':
                self.parent.searchDict.update({str(key):text})
        self.close()
    def onReject(self):
        """
        return empty search dictionary and close dialog window
        """
        self.parent.searchDict = {}
        self.close()
#}}}

class MainWindow(QMainWindow, Ui_MainWindow):
    def __init__(self,parent=None):
        super(MainWindow, self).__init__(parent)
        self.mainFrame = Ui_MainWindow()
        self.mainFrame.setupUi(self)
        self.dataDict = {}
        # Create the plot
        self.createPlotBox(self.mainFrame.plotWidget)
        self.createPlotBox(self.mainFrame.plotWidget1)
        self.createPlotBox(self.mainFrame.plotWidget2)
        self.connectDatabase()

        self.databaseParamsDict = dtb.returnDatabaseDictionary(self.collection)
        self.databaseParamsDict.pop('otherNotes')
        self.mainFrame.browseDatabaseButton.clicked.connect(self.on_pushButton_clicked)
        self.databaseBrowser = MyDatabaseBrowser(self)

        # Connections
        self.mainFrame.plotSelected.clicked.connect(self.onPlot)
        self.mainFrame.dataListWidget.itemClicked.connect(self.listGetItem)
        self.mainFrame.addToListButton.clicked.connect(self.addToSelected)

        # for the list checkbox
        self.mainFrame.checkableList = QStandardItemModel(self.mainFrame.selectedDataListView)
        self.mainFrame.checkableList.itemChanged.connect(self.onItemChanged)


    def findAndAddSets(self):#{{{
        """ Find the sets that are defined by the selections in the combo boxes and populates the dataListWidget with the expNames.
        """
        self.mainFrame.dataListWidget.clear()
        self.listOfSets = list(self.collection.find(self.searchDict))
        self.expNames = []
        for dataSet in self.listOfSets:
            self.expNames.append(str(dataSet.get('expName')))
        self.mainFrame.dataListWidget.addItems(self.expNames)#}}}

    @QtCore.pyqtSlot()#{{{
    def on_pushButton_clicked(self):
        self.databaseBrowser.exec_()
        self.findAndAddSets()
        #}}}

    def onItemChanged(self):
        self.itemsToPlot = []
        i = 0
        while self.mainFrame.checkableList.item(i):
            if self.mainFrame.checkableList.item(i).checkState():
                # the item is checked so update the plot and do things 
                self.itemsToPlot.append(self.mainFrame.checkableList.item(i).text())
            i+=1

    def listGetItem(self):
        self.currentListSelection = str(self.expNames[self.mainFrame.dataListWidget.currentRow()])

    def addToSelected(self):#{{{
        """ Adds the currently selected listWidget item to the dataListView and plots the current listWidget item.
        """
        self.listGetItem()
        item = QStandardItem(self.currentListSelection)
        item.setCheckable(True)
        item.setCheckState(QtCore.Qt.CheckState(QtCore.Qt.Checked)) # set the item to checked
        self.mainFrame.checkableList.appendRow(item)
        self.mainFrame.selectedDataListView.setModel(self.mainFrame.checkableList)
        #}}}

    def calculateFits(self):#{{{
        """ Calculate the fits to both the T1 set and the kSigma set 
        """
        dataSet = list(self.collection.find({'expName':self.currentListSelection}))[0]
        t1Data = dtb.dictToNdData('t1Power',dataSet)
        t1Data.sort('power')
        # weighted fit as function of power
        out = minimize(residualLinear, params, args=(t1Data.getaxis('power'), t1Data.runcopy(pys.real).data, t1Data.get_error()))
        t1Fit = pys.nddata(analyticLinear(out.params,t1Data.getaxis('power'))).rename('value','power').labels('power',t1Data.getaxis('power'))
        kSigmaData = dtb.dictToNdData('kSigma',dataSet,retValue = False) 
        kSigmaData = nmrfit.ksp(kSigmaData)
        kSigmaData.fit()
        self.dataDict.update({self.currentListSelection:{'kSigma':kSigmaData,'t1Set':t1Data,'t1SetFit':t1Fit}})
        #}}}

    def onPlot(self):#{{{
        """ Draw the plots
        This is called from calculateFits and from...

        """
        self.calculateFits()
        t1Data = self.dataDict.get(self.currentListSelection).get('t1Set')
        t1Fit = self.dataDict.get(self.currentListSelection).get('t1SetFit')
        kSigmaData = self.dataDict.get(self.currentListSelection).get('kSigma')
        self.mainFrame.plotWidget1.axes.plot(t1Data.getaxis('power'),t1Data.data, 'r.')
        self.mainFrame.plotWidget1.axes.plot(t1Fit.getaxis('power'),t1Fit.data, 'g')
        self.mainFrame.plotWidget1.axes.legend()
        self.mainFrame.plotWidget1.canvas.draw()
        self.mainFrame.plotWidget.axes.plot(kSigmaData.getaxis('power'),kSigmaData.data, 'r.')
        self.mainFrame.plotWidget.axes.plot(kSigmaData.eval(100).getaxis('power'),kSigmaData.eval(100).data, 'g')
        self.mainFrame.plotWidget.axes.legend()
        self.mainFrame.plotWidget.canvas.draw()#}}}

    def createPlotBox(self,plotObject):#{{{
        """
        This creates an mpl figure instance given a container to put it in
        """
        # Create the mpl Figure and FigCanvas objects. 
        # 5x4 inches, 100 dots-per-inch
        #
        self.dpi = 100
        plotObject.fig = Figure((4.0, 4.0), dpi=self.dpi)
        plotObject.canvas = FigureCanvas(plotObject.fig)
        plotObject.canvas.setParent(plotObject)
        
        # Since we have only one plot, we can use add_axes 
        # instead of add_subplot, but then the subplot
        # configuration tool in the navigation toolbar wouldn't
        # work.
        #
        plotObject.axes = plotObject.fig.add_subplot(111)
        
        # Bind the 'pick' event for clicking on one of the bars
        #
        #self.canvas.mpl_connect('pick_event', self.on_pick)
        
        # Create the navigation toolbar, tied to the canvas
        #
        plotObject.mpl_toolbar = NavigationToolbar(plotObject.canvas, plotObject)
        # layout in a vbox
        vbox = QVBoxLayout()
        vbox.addWidget(plotObject.canvas)
        vbox.addWidget(plotObject.mpl_toolbar)
        
        # set everything to the mainFrame
        plotObject.setLayout(vbox)#}}}

    def connectDatabase(self):#{{{
        self.MONGODB_URI = 'mongodb://rbarnes:tgb47atgb47a@ds047040.mongolab.com:47040/magresdata' 
        #self.conn = pymongo.MongoClient(self.MONGODB_URI) # Connect to the database that I purchased
        #db = self.conn.magresdata # 'dynamicalTransition' is the name of my test database
        #self.collection = db.hanLabODNPTest # This is my test collection
        self.conn = pymongo.MongoClient('localhost',27017) # Connect to the database that I purchased
        db = self.conn.homeDB # 'dynamicalTransition' is the name of my test database
        self.collection = db.localData # This is my test collection#}}}

if __name__ == '__main__':
    app = QApplication(sys.argv)
    frame = MainWindow()
    frame.show()
    app.exec_()
