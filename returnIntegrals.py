from h5nmr import *
import nmrfit
import os
import csv
from cStringIO import StringIO
import sys
import subprocess
import pickle

#{{{ Various definitions and classes
#{{{ Class function for grabbing python output. ->> This should be moved to fornotebook or something.
class Capturing(list):
    def __enter__(self):
        self._stdout = sys.stdout
        sys.stdout = self._stringio = StringIO()
        return self
    def __exit__(self, *args):
        self.extend(self._stringio.getvalue().splitlines())
        sys.stdout = self._stdout
#}}}

#{{{ Compile the pdf output
def compilePDF(name):
    print "Compiling pdf"
    with Capturing() as output:
        fl.show(name + '.pdf')
    texFile = open(name+'/plots.tex','wb')
    header = [
        '\\documentclass[10pt]{book}',
        '\\usepackage{mynotebook}',
        '\\usepackage{mysoftware_style}',
        '\\newcommand{\\autoDir}{/Users/StupidRobot/Projects/WorkupSoftware/notebook/auto_figures/}',
        '\\usepackage{cite}', 
        '\\usepackage{ulem}',

        '\\title{workup %s}'%name,

        '\\date{\\today}',
        '\\begin{document}',
        '\\maketitle',]
    for line in header:
        texFile.write(line + '\n')
    for line in output:
        texFile.write(line + '\n')
    texFile.write('\\end{document}')
    texFile.close()
    subprocess.call(['pdflatex','--output-directory %s/'%name, '%s/plots.tex'%name])
    subprocess.call(['mv','plots.pdf', '%s/'%name])
    subprocess.call(['open','-a','/Applications/Preview.app','%s/plots.pdf'%name])
    #open -a /Applications/Preview.app 'plots.pdf'
#}}}

def writeDict(fileName,dictionary):#{{{ Dictionary read write functions
    with open(fileName,'wb') as f:
        pickle.dump(dictionary,f,pickle.HIGHEST_PROTOCOL)
    f.close()
def loadDict(fileName):
    with open(fileName,'rb') as f:
        dic = pickle.load(f)
        f.close()
        return dic #}}}
#}}}

### Things that still need done.
### 1) system calls that handle both windows and mac both in naming the file type and in compiling the pdf.
### 1a) Make a way to reload the freshly produced pdf. Mac will work with preview (you just need to set to use preview by default). Windows should work with Sumatra pdf --> This seems to work for mac nicely, need to add windows features now.
### 2) Axis labels in the last plots generated by the code.
### 3) Add code to just work up the T1 experiment if this is for a T10
### 4) Newton's method to find starting guess for T10 experiment
### 5) Database information? - yes. Database the experiment info (1) t1 integrals and power values, (2) kSigma power series and value, and (3) enhancement series
#### The database should be ordered {operator,setType (kSigma, T1Series, enhancementSeries, T10, EPR), Macromolecule, bindingPartner, concentration, temperature(K)
### 6) EPR workup and double integrals --> This might need to come later once you can do the baseline subtraction correctly.

close('all')
fl = figlistl()
header = '/Users/StupidRobot/exp_data/'
path = 'ryan_cnsi/nmr/'
name = raw_input('What is the experiment file name that you wish to work up? ')
name = str(name)

fullPath = header + path + name
expParametersFile = name + '/' + 'parameters.pkl'

### make the experiment directory to dump all of the high level data
try:
    os.mkdir(name)
except:
    print "file exists"
    pass

#{{{ The initial parameters, these get changed in the terminal interface
dnpExps = r_[5:27]
t1Exp = r_[28:38,304]
integrationWidth = 1.5e2
t1StartingGuess = 1.14 ### This is the best guess for what your T1's are, if your T1 fits don't come out change this guess!!
ReturnKSigma = True ### This needs to be False because my code is broken
t1SeparatePhaseCycle = True ### Did you save the phase cycles separately?
thresholdE = 0.3
thresholdT1 = 0.3
badT1 = []
#}}}

### Check for parameters file, write new file if DNE, else pull parameters file#{{{
expExists = os.path.isfile(expParametersFile)
if not expExists: # If we don't have the exp specific parameters file yet make the parameter dictionary from the information above and edit with the following.
    parameterDict = {'dnpExps':dnpExps,
                    't1Exp':t1Exp,
                    'integrationWidth':integrationWidth,
                    't1StartingGuess':t1StartingGuess,
                    'ReturnKSigma':ReturnKSigma,
                    't1SeparatePhaseCycle':t1SeparatePhaseCycle,
                    'thresholdE':thresholdE,
                    'thresholdT1':thresholdT1,
                    'badT1':badT1
                    }
    ### Write the parameter Dictionary to the file
    writeDict(expParametersFile,parameterDict)
else:
    ### Pull all the parameters from the file stored specifically for this experiment
    parameterDict = loadDict(expParametersFile)
    dnpExps = parameterDict.get('dnpExps') 
    t1Exp = parameterDict.get('t1Exp')
    integrationWidth = parameterDict.get('integrationWidth')
    t1StartingGuess = parameterDict.get('t1StartingGuess') ### This is the best guess for what your T1's are, if your T1 fits don't come out change this guess!!
    ReturnKSigma = parameterDict.get('ReturnKSigma') ### This needs to be False because my code is broken
    t1SeparatePhaseCycle = parameterDict.get('t1SeparatePhaseCycle') ### Did you save the phase cycles separately?
    thresholdE = parameterDict.get('thresholdE')
    thresholdT1 = parameterDict.get('thresholdT1')
    badT1 = parameterDict.get('badT1')
#}}}

#{{{ Index Files
files = listdir(fullPath)
### Just weed out the power files from the titles, we already know what they are
for index,item in enumerate(files):
    if item == 't1_powers.mat':
        files.pop(index)
for index,item in enumerate(files):
    if item == 'power.mat':
        files.pop(index)
files = [double(i) for i in files]
files.sort()
expTitles = []
for i in files:
    try:
        titleName = load_title(fullPath + '/' + str(i).split('.')[0])
        try: 
            titleName = titleName.split('\r')[0]
        except:
            pass
        expTitles.append([titleName,str(i).split('.')[0]])
    except:
        pass
        print "Couldn't read the experiment title for some reason. Leaving blank"
#}}}

#{{{ DNP Experiment?
dnpexp = raw_input("\n\nIs this a DNP experiment or T10? If DNP, hit enter. If T10 type 'T10'")
if dnpexp == '': # DNP is True, T10 is False
    dnpexp = True
else:
    dnpexp = False
#}}}

### Go through and edit parameters from user input#{{{ You should have a different set of questions for the T1 and the ODNP
answer = True
while answer:
    answer = raw_input("\n\nWould you like to edit any of the following ODNP parameters? \n (1) dnpExps \n (2) t1Exps \n (3) integrationWidth \n (4) t1StartingGuess \n (5) ReturnKSigma \n (6) t1SeparatePhaseCycle \n (7) thresholdE \n (8) thresholdT1 \n (9) badT1 \n If yes, enter the number of the parameter. If not simply hit enter. ")
    if answer == '':
        answer = False # break the while loop and continue
    try:
        if eval(answer) == 1: # dnp experiment number#{{{
            newAnswer = raw_input("The current dnp experiments are \n\n %s \n\n if you would like to change the experiment numbers enter them as an array, such as r_[5:27] "%dnpExps)
            if newAnswer == '':
                continue
            else:
                dnpExps = eval(newAnswer)
                parameterDict.update({'dnpExps':dnpExps})#}}}
        if eval(answer) == 2: # t1 Exp experiment number#{{{
            newAnswer = raw_input("The current t1 experiments are \n\n %s \n\n if you would like to change the experiment numbers enter them as an array, such as r_[28:38,304] "%t1Exp)
            if newAnswer == '':
                continue
            else:
                t1Exp = eval(newAnswer)
                parameterDict.update({'t1Exp':t1Exp})#}}}
        if eval(answer) == 3: # integration width#{{{
            newAnswer = raw_input("The current integration width is  %0.2f if you would like to change the integration width enter the new value "%integrationWidth)
            if newAnswer == '':
                continue
            else:
                integrationWidth = eval(newAnswer)
                parameterDict.update({'integrationWidth':integrationWidth})#}}}
        if eval(answer) == 4: # integration width#{{{
            newAnswer = raw_input("The current T1 starting guess is %0.2f. This is used as the starting guess for the t1 fit. If you would like to change the starting guess enter the new value "%t1StartingGuess)
            if newAnswer == '':
                continue
            else:
                t1StartingGuess = eval(newAnswer)
                print "T1 starting guess changed to ",t1StartingGuess
                parameterDict.update({'t1StartingGuess':t1StartingGuess})#}}}
        if eval(answer) == 5: # ReturnKSigma#{{{
            if ReturnKSigma:
                statusString = "The current setting is to return the Ksigma data set. If you would like Ksigma returned enter '1'. If you would not like ksigma returned enter '0'"
            else:
                statusString = "The current setting is to not return the Ksigma data set. If you would like Ksigma returned enter '1'. If you would not like ksigma returned enter '0'"
            newAnswer = raw_input(statusString)
            if newAnswer == '':
                continue
            else:
                ReturnKSigma = eval(newAnswer)
                print "ReturnKSigma changed to ",ReturnKSigma
                parameterDict.update({'ReturnKSigma':ReturnKSigma})#}}}
        if eval(answer) == 6: # t1SeparatePhaseCycle#{{{
           newAnswer = raw_input("If you saved the phase cycles separately for the T1 measurement enter '1'. If you had Bruker work up the phase cycles enter '0'")
           if newAnswer == '':
               continue
           else:
               t1SeparatePhaseCycle = eval(newAnswer)
               print "t1SeparatePhaseCycle changed to ",t1SeparatePhaseCycle
               parameterDict.update({'t1SeparatePhaseCycle':t1SeparatePhaseCycle})#}}}
        if eval(answer) == 7: # thresholdE#{{{
             newAnswer = raw_input("The current enhancement power threshold level is %0.2f dBm. If you would like to change it enter the new value. "%thresholdE)
             if newAnswer == '':
                 continue
             else:
                 thresholdE = eval(newAnswer)
                 print "thresholdE changed to ",thresholdE
                 parameterDict.update({'thresholdE':thresholdE})#}}}
        if eval(answer) == 8: # thresholdT1#{{{
             newAnswer = raw_input("The current T1 power threshold level is %0.2f dBm. If you would like to change it enter the new value. "%thresholdT1)
             if newAnswer == '':
                 continue
             else:
                 thresholdT1 = eval(newAnswer)
                 print "thresholdT1 changed to ",thresholdT1
                 parameterDict.update({'thresholdT1':thresholdT1})#}}}
        if eval(answer) == 9: # badT1 #{{{
             newAnswer = raw_input("Enter the T1 experiment numbers that you would like to drop from the T1 series. This is how you will throw out T1 values that came from noisy experiments. Enter the experiment numbers as a list like '[28,34]'. \n\n Also currently I'm throwing out these experiments %s "%badT1)
             if newAnswer == '':
                 continue
             else:
                 badT1 = eval(newAnswer)
                 print "badT1 changed to ",badT1
                 parameterDict.update({'badT1':badT1})#}}}
    except:
        pass
    writeDict(expParametersFile,parameterDict) # write the new parameters to a file for later use.
#}}}

### Work up the power files#{{{
if dnpexp: # only work up files if DNP experiment
    # The enhancement series#{{{
    fl.figurelist.append({'print_string':r'\subparagraph{Enhancement Power Measurement}' + '\n\n'})
    enhancementPowers,fl.figurelist = returnSplitPowers(fullPath,'power.mat',expTimeMin = 70,dnpPowers = True,threshold = thresholdE,titleString = 'Enhancement ',firstFigure = fl.figurelist)
    enhancementPowers = list(enhancementPowers)
    enhancementPowers.insert(0,-100)
    enhancementPowers = array(enhancementPowers)
    enhancementPowers = dbm_to_power(enhancementPowers)
    ### Error handling for the enhancement powers and integration file#{{{
    if len(enhancementPowers) != len(dnpExps): ### There is something wrong. Show the power series plot and print the dnpExps
        fl.figurelist.append({'print_string':r'\subsection{\large{ERROR: Read Below to fix!!}}' + '\n\n'})#{{{ Error text
        fl.figurelist.append({'print_string':"Before you start, the terminal (commandline) is still alive and will walk you through making edits to the necessary parameters to resolve this issue. \n\n \large(Issue) The number of power values, %d, and the number of enhancement integrals, %d, does not match. This is either because \n\n (1) I didn't return the correct number of powers or \n\n (2) You didn't enter the correct number of dnp experiments. \n\n If case (1) look at plot 'Enhancement Derivative powers' the black line is determined by 'thresholdE' in the code. Adjust the threshold value such that the black line is below all of the blue peaks that you suspect are valid power jumps. \n\n If case (2) look through the experiment titles, listed below and make sure you have set 'dnpExps' correctly. Also shown below. Recall that the last experiment in both the DNP and T1 sets is empty."%(len(enhancementPowers),len(dnpExps)) + '\n\n'})
        fl.figurelist.append({'print_string':r'\subsection{Experiment Titles and Experiment Number}' + '\n\n'})
        for title in expTitles:
            fl.figurelist.append({'print_string':"%s"%title + '\n\n'})#}}}
        compilePDF(name)
        answer = raw_input("\n\n --> Do you need to adjust the thresholdE parameter? Currently thresholdE = %0.2f. (If no, type 'no'. If yes, type the new threshold value e.g. '0.5') \n\n ->> "%thresholdE)
        if answer != 'no':
            parameterDict.update({'thresholdE':eval(answer)})
            print"\n\n Parameter Saved \n\n"
        answer = raw_input("\n\n --> Do you need to adjust the DNP experiment numbers? (If no, type 'no'. If yes, type the new experiment numbers.) \n\n An appropriate answer would be r_[5:27] (this gives an array of values from 5 upto but not including 27) \n\n ->> ")
        if answer != 'no':
            parameterDict.update({'dnpExps':eval(answer)})
            print"\n\n Parameter Saved \n\n"
        writeDict(expParametersFile,parameterDict)
        raise ValueError("\n\n Please close the pdf and re-run the script")
    #}}}
    # Open the enhancement powers file and dump to csv
    powerFile = loadmat(fullPath + '/power.mat')
    powersE = powerFile.pop('powerlist')
    powersE = dbm_to_power(powersE)
    powersE = [x for i in powersE for x in i]
    timesE = powerFile.pop('timelist')
    timesE = [x for i in timesE for x in i]
    #}}}

    # The T1 Power Series#{{{
    fl.figurelist.append({'print_string':r'\subparagraph{$T_1$ Power Measurement}' + '\n\n'})
    t1Power,fl.figurelist = returnSplitPowers(fullPath,'t1_powers.mat',expTimeMin = 100,dnpPowers = False,threshold = thresholdT1,titleString = 'T1 ',firstFigure = fl.figurelist)
    t1Power = list(t1Power)
    t1Power.append(-99.0) # Add the zero power for experiment 304
    t1Power = array(t1Power)
    t1Power = dbm_to_power(t1Power)
    ### Error handling for the T1 powers and integration file#{{{
    if len(t1Power) != len(t1Exp): ### There is something wrong. Show the power series plot and print the dnpExps
        fl.figurelist.append({'print_string':r'\subsection{\large{ERROR: Read Below to fix!!}}' + '\n\n'})#{{{ Error text
        fl.figurelist.append({'print_string':"Before you start, the terminal (commandline) is still alive and will walk you through making edits to the necessary parameters to resolve this issue. \n\n \large(Issue:) The number of power values, %d, and the number of $T_1$ integrals, %d, does not match. This is either because \n\n (1) I didn't return the correct number of powers or \n\n (2) You didn't enter the correct number of T1 experiments. \n\n If case (1) look at plot 'T1 Derivative powers' the black line is determined by 'thresholdT1' in the code. Adjust the threshold value such that the black line is below all of the blue peaks that you suspect are valid power jumps. \n\n If case (2) look through the experiment titles, listed below and make sure you have set 't1Exp' correctly. Also shown below. Recall that the last experiment in both the DNP and T1 sets is empty."%(len(t1Power),len(t1Exp)) + '\n\n'})
        fl.figurelist.append({'print_string':r'\subsection{Experiment Titles and Experiment Number}' + '\n\n'})
        for titleName in expTitles:
            fl.figurelist.append({'print_string':"%s"%titleName + '\n\n'})#}}}
        compilePDF(name)
        answer = raw_input("\n\n --> Do you need to adjust the thresholdT1 parameter? Currently thresholdT1 = %0.2f. (If no, type 'no'. If yes, type the new threshold value e.g. '0.5') \n\n ->> "%thresholdT1)
        if answer != 'no':
            parameterDict.update({'thresholdT1':eval(answer)})
            print"\n\n Parameter Saved \n\n"
        answer = raw_input("\n\n --> Do you need to adjust the T1 experiment numbers? (If no, type 'no'. If yes, type the new experiment numbers.) \n\n An appropriate answer would be r_[28:38,304] (this gives an array of values from 28 upto but not including 38 and adds the number 304 to the end of the array.) \n\n ->> ")
        if answer != 'no':
            parameterDict.update({'t1Exp':eval(answer)})
            print"\n\n Parameter Saved \n\n"
        writeDict(expParametersFile,parameterDict)
        print"\n\n Updated parameters are saved \n\n"
        raise ValueError("\n\n Please close the pdf and re-run the script")
    #}}}

    # Open the t1 powers file and dump to csv
    powerFile = loadmat(fullPath + '/t1_powers.mat')
    powersT1 = powerFile.pop('powerlist')
    powersT1 = dbm_to_power(powersT1)
    powersT1 = [x for i in powersT1 for x in i]
    timesT1 = powerFile.pop('timelist')
    timesT1 = [x for i in timesT1 for x in i]
    #}}}
#}}}

#{{{ Enhancement Integration
if dnpexp:
    ### EnhancementSeries
    fl.figurelist.append({'print_string':r'\subparagraph{Enhancement Series}' + '\n\n'})
    enhancementSeries,fl.figurelist = integrate(fullPath,dnpExps,integration_width = integrationWidth,phchannel = [-1],phnum = [4],first_figure = fl.figurelist)
    enhancementSeries.rename('power','expNum').labels(['expNum'],[dnpExps])
    ### Fit and plot the Enhancement
    enhancementSeries = enhancementSeries.runcopy(real)
    fl.figurelist = nextfigure(fl.figurelist,'EnhancementExpSeries')
    ax = gca()
    plot(enhancementSeries.copy().set_error(None),'b',alpha = 0.5)
    title('NMR Enhancement')
    # Try to append the power file to the enhancement series#{{{
    try:
        enhancementPowerSeries = enhancementSeries.copy()
        enhancementPowerSeries.rename('expNum','power').labels(['power'],[enhancementPowers])
        ### Fit and plot the Enhancement
        enhancementPowerSeries = enhancementPowerSeries.runcopy(real)
        enhancementPowerSeries.data /= enhancementPowerSeries.data[0]
        enhancementPowerSeries = nmrfit.emax(enhancementPowerSeries,verbose = False)
        enhancementPowerSeries.fit()
        fl.figurelist = nextfigure(fl.figurelist,'EnhancementPowerSeries')
        ax = gca()
        text(0.5,0.5,enhancementPowerSeries.latex(),transform = ax.transAxes,size = 'x-large', horizontalalignment = 'center',color = 'b')
        plot_updown(enhancementPowerSeries.copy().set_error(None),'power','r','b',alpha = 0.5)
        plot(enhancementPowerSeries.eval(100))
        title('NMR Enhancement')
    except:
        fl.figurelist.append({'print_string':r"I couldn't match the power indecies to the enhancement series. You will have to do this manually in the csv file 'enhancementPowers.csv'" + '\n\n'})
        enhancementPowerSeries = False
    #}}}
#}}}

#{{{ T1 Integration
### The T1 Series
# Power File
t1SeriesList = [] # There is probably a much better way to do this than with just a bunch of lists but this works for now.
t1DataList = []
t1ErrList = []
if dnpexp:
    t1SeriesListgood = []
    t1DataListgood = []
    t1ErrListgood = []
    t1PowerClean = []
print "Running your T1 series"
fl.figurelist.append({'print_string':r'\subparagraph{T_1 Series}' + '\n\n'})
for count,expNum in enumerate(t1Exp):
    print "integrating data from expno %0.2f"%expNum
    if dnpexp:
        fl.figurelist.append({'print_string':r'$T_1$ experiment %d at power %0.2f dBm'%(expNum,t1Power[count]) + '\n\n'})
    else:
        fl.figurelist.append({'print_string':r'$T_1$ experiment %d'%(expNum) + '\n\n'})
    if t1SeparatePhaseCycle: # The phase cycles are saved separately 
        rawT1,fl.figurelist = integrate(fullPath,expNum,integration_width = integrationWidth,phchannel = [-1],phnum = [4],first_figure = fl.figurelist,pdfstring = 't1Expno_%d'%(expNum))
    else: # the phase cycle is already performed on the Bruker
        rawT1,fl.figurelist = integrate(fullPath,expNum,integration_width = integrationWidth,phchannel = [],phnum = [],first_figure = fl.figurelist,pdfstring = 't1Expno_%d'%(expNum))
    rawT1.rename('power','delay')
    print "pulling delay from expno %0.2f"%expNum
    delay = bruker_load_vdlist(fullPath + '/%d/' %expNum)
    rawT1.labels(['delay'],[delay])
    rawT1 = nmrfit.t1curve(rawT1.runcopy(real),verbose = False) 
    s2 = float(rawT1['delay',-1].data)
    s1 = -s2
    rawT1.starting_guesses.insert(0,array([s1,s2,t1StartingGuess]))
    rawT1.fit()
    fl.figurelist = nextfigure(fl.figurelist,'t1RawDataExp%d'%(expNum))
    ax = gca()
    title('T1 Exp %0.2f'%(expNum))
    text(0.5,0.75,rawT1.latex(),transform = ax.transAxes,size = 'x-large', horizontalalignment = 'center',color = 'k')
    plot(rawT1,'r.')
    plot(rawT1.eval(100))
    plot(rawT1 - rawT1.eval(100).interp('delay',rawT1.getaxis('delay')).runcopy(real),'g.')
    if dnpexp:
        if expNum in badT1:
            fl.figurelist.append({'print_string':"\large{Experiment excluded from $T_1$ series." + '\n\n'})
        else:
            t1DataListgood.append(rawT1.output(r'T_1'))
            t1ErrListgood.append(sqrt(rawT1.covar(r'T_1')))
            t1SeriesListgood.append(rawT1)
            t1PowerClean.append(t1Power[count])
    t1DataList.append(rawT1.output(r'T_1'))
    t1ErrList.append(sqrt(rawT1.covar(r'T_1')))
    t1SeriesList.append(rawT1)
# The t1 of experiment series
t1Series = nddata(array(t1DataList)).rename('value','expNum').labels(['expNum'],[t1Exp]).set_error(array(t1ErrList))
#{{{  The T1 power series
if dnpexp:
    try:
        t1PowerSeries = nddata(array(t1DataListgood)).rename('value','power').labels(['power'],[array(t1PowerClean)]).set_error(array(t1ErrListgood))
        fl.figurelist = nextfigure(fl.figurelist,'T1PowerSeries')
        plot(t1PowerSeries,'r.')
        xlim(t1PowerSeries.getaxis('power').min()-0.2,t1PowerSeries.getaxis('power').max()+0.2)
        title('$T_1$ Power Series')
    except:
        t1PowerSeries = False
        fl.figurelist.append({'print_string':r"I couldn't match the power indecies to the $T_1$ series. You will have to do this manually in the csv file 't1Powers.csv'" + '\n\n'})
#}}}
#}}}

### Compute kSigma if the powers files worked out#{{{
if dnpexp:
    if ReturnKSigma and enhancementPowerSeries and t1PowerSeries: # Both power series worked out
        R1 = nddata(t1Series['expNum',lambda x: x == 304].data).set_error(t1Series['expNum',lambda x: x == 304].get_error())
        #{{{ Fit the relaxation rate power series
        rateSeries = 1/t1PowerSeries.runcopy(real)
        powers = linspace(0,t1PowerSeries.getaxis('power').max(),100)
        ### 2nd order fit
        c,fit = rateSeries.copy().polyfit('power',order = 2)
        fit.set_error(array(rateSeries.get_error())) # this is really not right but for now just winging something this'll put us in the ball park
        rateFit = nddata(c[0] + c[1]*powers + c[2]*powers**2).rename('value','power').labels(['power'],[powers])
        #### 1st order fit
        #c,fit = rateSeries.polyfit('power',order = 1)
        #fit.set_error(array(rateSeries.get_error())) # this is really not right but for now just winging something this'll put us in the ball park
        #rateFit = nddata(c[0] + c[1]*powers).rename('value','power').labels(['power'],[powers])
        fl.figurelist = nextfigure(fl.figurelist,'Rate Series')
        plot(rateSeries,'r.')
        plot(rateFit)
        xlim(rateSeries.getaxis('power').min() - 0.1*rateSeries.getaxis('power').max(), rateSeries.getaxis('power').max() + 0.1*rateSeries.getaxis('power').max())
        ylim(0,rateSeries.data.max() + 0.1)
        title('Rate Series')
        #}}}
        kSigmaUCCurve = (1-enhancementPowerSeries.copy())*R1*(1./659.33)
        kSigmaUCCurve.popdim('value') # For some reason it picks this up from R1, I'm not sure how to do the above nicely 
        kSigmaUCCurve.set_error(None)
        kSigmaUCCurve = nmrfit.ksp(kSigmaUCCurve)
        kSigmaUCCurve.fit()
        kSigmaUC = ndshape([1],[''])
        kSigmaUC = kSigmaUC.alloc(dtype = 'float')
        kSigmaUC.data = array([kSigmaUCCurve.output(r'ksmax')])
        kSigmaUC.set_error(kSigmaUCCurve.covar(r'ksmax'))
        kSigmaCCurve = (1- enhancementPowerSeries.copy())*rateFit.copy().interp('power',enhancementPowerSeries.getaxis('power'))*(1./659.33)
        kSigmaCCurve = nmrfit.ksp(kSigmaCCurve)
        kSigmaCCurve.fit()
        kSigmaC = nddata(kSigmaCCurve.output(r'ksmax')).rename('value','').set_error(array([sqrt(kSigmaCCurve.covar(r'ksmax'))]))
        fl.figurelist = nextfigure(fl.figurelist,'kSigma')
        ax = gca()
        plot(kSigmaCCurve.copy().set_error(None),'r.',label = 'corr')
        plot(kSigmaCCurve.eval(100),'r-')
        text(0.5,0.5,kSigmaCCurve.latex(),transform = ax.transAxes,size = 'x-large', horizontalalignment = 'center',color = 'r')
        plot(kSigmaUCCurve.copy().set_error(None),'b.',label = 'un-corr')
        plot(kSigmaUCCurve.eval(100),'b-')
        text(0.5,0.25,kSigmaUCCurve.latex(),transform = ax.transAxes,size = 'x-large', horizontalalignment = 'center',color = 'b')
        title('$k_{\\sigma} \\ S_{max}\\ Conc$')
        legend(loc=4)
#}}}

#{{{ ### Write everything to a csv file as well
### Write the enhancement power file 
if dnpexp:
    if enhancementPowerSeries:
        enhancementPowersWriter = [('power (W)','Integral','Exp Num')] + zip(list(enhancementPowerSeries.getaxis('power')),list(enhancementPowerSeries.data),list(enhancementSeries.getaxis('expNum'))) + [('\n')] +  [('power (W)','time (s)')] + zip(list(powersE),list(timesE))
    else:
        enhancementPowersWriter = [('power (W)',)] + zip(list(enhancementPowers)) + [('\n')] +  [('power (W)','time (s)')] + zip(list(powersE),list(timesE))
    with open(name + '/enhancementPowers.csv','wb') as csvFile:
        writer = csv.writer(csvFile,delimiter =',')
        writer.writerows(enhancementPowersWriter)

    ### Write the T1 power file 
    if t1PowerSeries:
        t1PowersWriter = [('power (W)','T_1 (s)','T_1 error (s)','Exp Num')] + zip(list(t1PowerSeries.getaxis('power')),list(t1PowerSeries.data),list(t1PowerSeries.get_error()),list(t1Series.getaxis('expNum'))) + [('\n')] +  [('power (W)','time (s)')] + zip(list(powersT1),list(timesT1))
    else:
        t1PowersWriter = [('power (W)',)] + zip(list(t1Power)) + [('\n')] +  [('power (W)','time (s)')] + zip(list(powersT1),list(timesT1))
    with open(name + '/t1Powers.csv','wb') as csvFile:
        writer = csv.writer(csvFile,delimiter =',')
        writer.writerows(t1PowersWriter)

    ### Write the enhancement series
    enhancementSeriesWriter = [('integrationVal','error','expNum')] + zip(list(enhancementSeries.data),list(enhancementSeries.get_error()),list(enhancementSeries.getaxis('expNum')))
    with open(name + '/enhancementSeries.csv','wb') as csvFile:
        writer = csv.writer(csvFile,delimiter =',')
        writer.writerows(enhancementSeriesWriter)
    ### Write Ksigma
    if ReturnKSigma:
        kSigmaWriter = [('kSigma','error')] + zip(list(kSigmaC.data),list(kSigmaC.get_error())) + [('\n')] + [('kSigma','power')] + zip(list(kSigmaCCurve.runcopy(real).data),list(kSigmaCCurve.getaxis('power')))
        with open(name + '/kSigma.csv','wb') as csvFile:
            writer = csv.writer(csvFile,delimiter =',')
            writer.writerows(kSigmaWriter)

### Write the t1 series
t1SeriesWriter = [('t1Val (s)','error','expNum')] + zip(list(t1Series.data),list(t1Series.get_error()),list(t1Series.getaxis('expNum')))
with open(name + '/t1Series.csv','wb') as csvFile:
    writer = csv.writer(csvFile,delimiter =',')
    writer.writerows(t1SeriesWriter)

for count,t1Set in enumerate(t1SeriesList):
    t1SetWriter = [('integrationVal','error','delay')] + zip(list(t1Set.data),list(t1Set.get_error()),list(t1Set.getaxis('delay')))
    with open(name + '/t1Integral%d.csv'%t1Exp[count],'wb') as csvFile:
        writer = csv.writer(csvFile,delimiter =',')
        writer.writerows(t1SetWriter)
#}}}

### Compile the pdf and show results
compilePDF(name)




